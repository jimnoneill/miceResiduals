---
title: "Working with MICE Residuals: A Complete Workflow"
author: "Jim O'Neill"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with MICE Residuals: A Complete Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Introduction

This vignette demonstrates how to use the `miceResiduals` package to work with multiply imputed datasets when you need to extract and use model residuals. This is particularly useful when working with Restricted Cubic Splines (RCS) or other modeling approaches that require pooled data but where you need the residuals available in the original multiple imputation format.

## The Problem

When working with multiple imputation in R using the `mice` package, you often encounter situations where:

1. Your modeling approach (like RCS) doesn't work directly with multiple imputed datasets
2. You need to pool the data, fit models, and extract residuals  
3. You want to add those residuals back to each individual imputed dataset
4. You need to maintain the proper `mids` format for valid inference

This workflow is common in environmental health research, particularly when studying cannabis exposure effects.

## Setup

```{r load-packages}
library(miceResiduals)
library(mice)
library(dplyr)

# For demonstration, we'll use the built-in nhanes2 data
data(nhanes2, package = "mice")
```

## Step 1: Create Multiple Imputed Data

First, let's create some multiply imputed data to work with:

```{r create-mice}
# Create multiple imputations
# In practice, you'd use more imputations (20-30+)
set.seed(123)
imp_data <- mice(nhanes2, m = 5, printFlag = FALSE)
print(imp_data)
```

## Step 2: Fit Your Models

Now we fit the models we're interested in. For this example, we'll create models predicting cholesterol with different sets of predictors:

```{r fit-models}
# Fit baseline exposure model
baseline_model <- with(imp_data, glm(chl ~ age + bmi, family = gaussian()))

# Fit model with additional predictor (hypertension)
adjusted_model <- with(imp_data, glm(chl ~ age + bmi + hyp, family = gaussian()))

# Create a named list of models
models <- list(
  "baseline" = baseline_model,
  "adjusted" = adjusted_model
)

# Check the structure
str(models, max.level = 1)
```

## Step 3: Add Residuals to MICE Object

This is where the magic happens. The `add_residuals_to_mice()` function will:

- Extract all completed datasets from the `mids` object
- Add residuals from each model to each dataset
- Repack everything into a proper `mids` format

```{r add-residuals}
# Add residuals to the mids object
result <- add_residuals_to_mice(
  mice_object = imp_data,
  models = models,
  seed = 123
)

# Check what we got back
print(result)

# Look at the variable names - should include residual variables
names(result$data)
```

## Step 4: Explore the Results

Let's examine what happened:

```{r explore-results}
# Extract one completed dataset to see the structure
completed_sample <- complete(result, 1)
head(completed_sample)

# Check the residual variables
summary(completed_sample$residuals_baseline)
summary(completed_sample$residuals_adjusted)

# The residuals should be properly distributed around 0
hist(completed_sample$residuals_baseline, 
     main = "Distribution of Baseline Model Residuals",
     xlab = "Residuals")
```

## Step 5: Calculate Residual Differences

Often you want to examine the difference between models. For example, the difference between adjusted and baseline model residuals represents the effect of the additional predictor:

```{r residual-differences}
# Calculate residual differences
result_with_diff <- calculate_residual_differences(
  mice_object = result,
  model1_residuals = "residuals_baseline",
  model2_residuals = "residuals_adjusted", 
  new_var_name = "residuals_hyp_effect"
)

# Check the new variable
completed_with_diff <- complete(result_with_diff, 1)
summary(completed_with_diff$residuals_hyp_effect)

# This represents the effect of hypertension adjustment
hist(completed_with_diff$residuals_hyp_effect,
     main = "Effect of Hypertension Adjustment on Residuals",
     xlab = "Residual Differences")
```

## Step 6: Use Residuals in Further Analysis

Now you can use these residuals in subsequent analyses while maintaining proper multiple imputation inference:

```{r use-residuals}
# Example: Use baseline residuals as a predictor in a new model
residual_analysis <- with(result, glm(chl ~ residuals_baseline + age, family = gaussian()))

# Pool the results
pooled_results <- pool(residual_analysis)
summary(pooled_results)

# Example: Examine relationship between different residuals
residual_comparison <- with(result, lm(residuals_adjusted ~ residuals_baseline))
pool(residual_comparison) %>% summary()
```

## Advanced Usage: Building Exposure Models

For environmental health research, the package includes a helper function to build standardized exposure models:

```{r exposure-models}
# This function is particularly useful for cannabis/environmental research
# where you often compare models with/without exposure variables

# Simulate some environmental data
set.seed(456)
env_data <- data.frame(
  outcome1 = rnorm(25, 100, 15),
  outcome2 = rnorm(25, 50, 10),
  air_pollution = rnorm(25, 10, 3),
  smoking = rbinom(25, 1, 0.3),
  cannabis = rbinom(25, 1, 0.2),
  age = sample(20:65, 25, replace = TRUE),
  bmi = rnorm(25, 25, 4)
)

# Add some missing values
env_data$air_pollution[sample(25, 5)] <- NA
env_data$bmi[sample(25, 3)] <- NA

# Create imputations
env_imp <- mice(env_data, m = 3, printFlag = FALSE)

# Build exposure models automatically
exposure_models <- build_exposure_models(
  mice_object = env_imp,
  outcome_vars = c("outcome1", "outcome2"),
  base_predictors = c("air_pollution", "smoking", "age", "bmi"),
  marijuana_var = "cannabis"
)

# This creates models with and without cannabis for each outcome
names(exposure_models)

# Add all residuals at once
env_result <- add_residuals_to_mice(env_imp, exposure_models)
names(env_result$data)
```

## Best Practices

### 1. Use Sufficient Imputations
In practice, use 20-30+ imputations for reliable results:

```{r best-practices-imputations, eval=FALSE}
# Better approach for real analysis
imp_data_final <- mice(my_data, m = 30, printFlag = FALSE)
```

### 2. Validate Your Models
Always check that your models make sense before extracting residuals:

```{r best-practices-validation, eval=FALSE}
# Check model fit
summary(pool(baseline_model))

# Check residual patterns
plot(baseline_model$analyses[[1]], which = 1:2)
```

### 3. Use Descriptive Names
Use descriptive names for your models to keep track of what each represents:

```{r best-practices-names}
descriptive_models <- list(
  "age_bmi_only" = baseline_model,
  "age_bmi_hyp" = adjusted_model
)
```

### 4. Document Your Workflow
Always document why you're using residuals and how they'll be interpreted:

```{r best-practices-documentation, eval=FALSE}
# Document your approach
# We're using residuals from the baseline model to examine
# patterns not explained by age and BMI alone...
```

## Troubleshooting

### Common Issues

**Error: "Model must be fitted with mice::with()"**
- Make sure you're using `with(mice_object, model_formula)` not `glm()` directly

**Error: "Variables not found"**  
- Check that variable names match between your models and data

**Memory issues with large datasets**
- Consider processing fewer imputations at a time
- Use the `gc()` function to clean up memory between steps

### Debugging Tips

```{r debugging, eval=FALSE}
# Check imputation structure
str(imp_data, max.level = 2)

# Check model structure  
str(models[[1]], max.level = 1)

# Validate inputs before processing
validate_mids(imp_data)
validate_model_list(models)
```

## Conclusion

The `miceResiduals` package streamlines a complex workflow that's common in environmental health research and other fields using multiple imputation. By automating the process of extracting, adding, and repacking residuals, it reduces errors and makes your analysis more reproducible.

Key benefits:

- **Maintains statistical validity** by preserving the multiple imputation structure
- **Reduces manual errors** in data manipulation  
- **Standardizes workflows** across different analyses
- **Enables complex residual-based analyses** while maintaining proper inference

For cannabis research and other environmental health applications, this package enables sophisticated analyses that account for both missing data and complex exposure patterns.

## Session Info

```{r session-info}
sessionInfo()
```



